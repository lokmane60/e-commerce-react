"use strict";
const VM = require("vm-plus");
const resolve_1 = require("resolve");
const events_1 = require("events");
const path = require("path");
const fs = require("fs");
const builtinLibs = Object.keys(process.binding('natives')).filter(m => !/^_|^internal|\//.test(m));
class NodeModule {
    constructor(id, filename, _ctxt, parent = null) {
        this.id = id;
        this.filename = filename;
        this._ctxt = _ctxt;
        this.parent = parent;
        this.exports = {};
        this.children = [];
        this.cache = _ctxt.cache;
        this.require = (moduleName => {
            if (builtinLibs.indexOf(moduleName) !== -1) {
                return require(moduleName);
            }
            return _ctxt.load(moduleName, this).exports;
        });
        this.require.cache = _ctxt.cache;
        this.require.resolve = moduleName => resolve_1.sync(moduleName, { basedir: path.dirname(filename) });
    }
    _compile(content, filename) {
        if (filename !== undefined) {
            this.filename = filename;
        }
        if (content === undefined) {
            content = fs.readFileSync(this.filename, 'utf8');
        }
        switch (path.extname(module.filename)) {
            case '.js': {
                const code = stripShebang(stripBOM(content));
                this._ctxt._node._vm.run(code, {
                    __dirname: path.dirname(this.filename),
                    __filename: path.basename(this.filename),
                    exports: this.exports,
                    module: this,
                    require: this.require
                }, {
                    filename: this.filename
                });
                break;
            }
            case '.json': {
                const code = stripBOM(content);
                this.exports = JSON.parse(content);
                break;
            }
        }
    }
    /**
     * Performs a full reload of the script and all of its dependencies. The
     * original module is not touched in any way, allowing the both to run
     * simultaneously.
     */
    reload() {
        const ctxt = new LoadContext(this._ctxt._node, Object.create(null));
        const newer = ctxt.load(this.filename, this.parent);
        //this._newerModule = newer
        return newer;
    }
}
class LoadContext {
    constructor(_node, cache = Object.create(null)) {
        this._node = _node;
        this.cache = cache;
        this.load = (moduleName, parent = null, rootdir = process.cwd()) => {
            const modulePath = resolve_1.sync(moduleName, { basedir: parent !== null ? path.dirname(parent.filename) : rootdir });
            return this.loadResolved(modulePath, parent);
        };
    }
    loadResolved(modulePath, parent = null) {
        if (typeof this.cache[modulePath] !== 'undefined') {
            const module = this.cache[modulePath];
            if (parent !== null) {
                parent.children.push(module);
            }
            this._node.emit('require', { module });
            return module;
        }
        const module = this.cache[modulePath] = new NodeModule(modulePath, modulePath, this, parent);
        if (parent !== null) {
            parent.children.push(module);
        }
        module._compile();
        this._node.emit('require', { module });
        return module;
    }
}
class NodeVM extends events_1.EventEmitter {
    constructor() {
        super();
        this._vm = new VM();
        this._ctxt = new LoadContext(this);
        this.cache = Object.create(null);
        this._vm = new VM({
            globals: {
                process,
                Buffer,
                clearImmediate,
                clearInterval,
                clearTimeout,
                console,
                global,
                setImmediate,
                setInterval,
                setTimeout,
            }
        });
    }
    getModule(modulePath) {
        return this._ctxt.load(modulePath);
    }
}
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 * because the buffer-to-string conversion in `fs.readFileSync()`
 * translates it to FEFF, the UTF-16 BOM.
 */
function stripBOM(content) {
    if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
    }
    return content;
}
/**
 * Find end of shebang line and slice it off
 */
function stripShebang(content) {
    // Remove shebang
    var contLen = content.length;
    if (contLen >= 2) {
        if (content.charCodeAt(0) === 35 /*#*/ &&
            content.charCodeAt(1) === 33 /*!*/) {
            if (contLen === 2) {
                // Exact match
                content = '';
            }
            else {
                // Find end of shebang line and slice it off
                var i = 2;
                for (; i < contLen; ++i) {
                    var code = content.charCodeAt(i);
                    if (code === 10 /*\n*/ || code === 13 /*\r*/)
                        break;
                }
                if (i === contLen)
                    content = '';
                else {
                    // Note that this actually includes the newline character(s) in the
                    // new output. This duplicates the behavior of the regular expression
                    // that was previously used to replace the shebang line
                    content = content.slice(i);
                }
            }
        }
    }
    return content;
}
module.exports = NodeVM;
//# sourceMappingURL=index.js.map