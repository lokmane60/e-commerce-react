import VM = require('vm-plus')
import { sync as resolveSync } from "resolve"
import { EventEmitter } from "events"
import * as path from "path"
import * as fs from "fs"

interface ModCache {
  [name: string]: NodeModule
}

interface RequireFunc {
  (moduleName: string): any;
  resolve(moduleName: string): string;
  cache: ModCache
}

const builtinLibs = Object.keys(process.binding('natives')).filter(m => !/^_|^internal|\//.test(m))

class NodeModule {

  exports: { [key: string]: any } = {}

  children: NodeModule[] = []

  require: RequireFunc

  cache: ModCache;

  constructor(public id: string, public filename: string, public _ctxt: LoadContext, public parent: NodeModule = null) {
    this.cache = _ctxt.cache;
    this.require = (moduleName => {
      if (builtinLibs.indexOf(moduleName) !== -1) {
        return require(moduleName)
      }
      return _ctxt.load(moduleName, this).exports
    }) as any
    this.require.cache = _ctxt.cache;
    this.require.resolve = moduleName => resolveSync(moduleName, { basedir: path.dirname(filename) })
  }

  _compile(content?: string, filename?: string) {

    if (filename !== undefined) {
      this.filename = filename
    }
    if (content === undefined) {
      content = fs.readFileSync(this.filename, 'utf8')
    }

    switch (path.extname(module.filename)) {

    case '.js': {
      const code = stripShebang(stripBOM(content))
      this._ctxt._node._vm.run(code, { 
        __dirname: path.dirname(this.filename),
        __filename: path.basename(this.filename),
        exports: this.exports,
        module: this,
        require: this.require
      }, { 
        filename: this.filename
      })
      break

    } case '.json': {
      const code = stripBOM(content)
      this.exports = JSON.parse(content)
      break
    }

    }

  }

  /**
   * Performs a full reload of the script and all of its dependencies. The
   * original module is not touched in any way, allowing the both to run
   * simultaneously.
   */
  reload() {
    const ctxt = new LoadContext(this._ctxt._node, Object.create(null))
    const newer = ctxt.load(this.filename, this.parent)
    //this._newerModule = newer
    return newer
  }

}

class LoadContext {

  constructor(public _node: NodeVM, public cache: ModCache = Object.create(null)) {
  
  }
  
  loadResolved(modulePath: string, parent: NodeModule = null) {

    if (typeof this.cache[modulePath] !== 'undefined') {
      const module = this.cache[modulePath];
      if (parent !== null) {
        parent.children.push(module)
      }
      this._node.emit('require', { module })
      return module
    }

    const module = this.cache[modulePath] = new NodeModule(modulePath, modulePath, this, parent)
    if (parent !== null) {
      parent.children.push(module)
    }

    module._compile()

    this._node.emit('require', { module })

    return module
  }

  load = (moduleName: string, parent: NodeModule = null, rootdir = process.cwd()) => {
    const modulePath = resolveSync(moduleName, { basedir: parent !== null ? path.dirname(parent.filename) : rootdir })
    return this.loadResolved(modulePath, parent)
  }

}

class NodeVM extends EventEmitter {
  
  _vm = new VM()
  _ctxt = new LoadContext(this)

  cache = Object.create(null)

  constructor() {
    super()
    this._vm = new VM({ 
      globals: {
        process,
        Buffer,
        clearImmediate,
        clearInterval,
        clearTimeout,
        console,
        global,
        setImmediate,
        setInterval,
        setTimeout,
      }
    })
  }

  getModule(modulePath: string) {
    return this._ctxt.load(modulePath)
  }

}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 * because the buffer-to-string conversion in `fs.readFileSync()`
 * translates it to FEFF, the UTF-16 BOM.
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Find end of shebang line and slice it off
 */
function stripShebang(content) {
  // Remove shebang
  var contLen = content.length;
  if (contLen >= 2) {
    if (content.charCodeAt(0) === 35/*#*/ &&
        content.charCodeAt(1) === 33/*!*/) {
      if (contLen === 2) {
        // Exact match
        content = '';
      } else {
        // Find end of shebang line and slice it off
        var i = 2;
        for (; i < contLen; ++i) {
          var code = content.charCodeAt(i);
          if (code === 10/*\n*/ || code === 13/*\r*/)
            break;
        }
        if (i === contLen)
          content = '';
        else {
          // Note that this actually includes the newline character(s) in the
          // new output. This duplicates the behavior of the regular expression
          // that was previously used to replace the shebang line
          content = content.slice(i);
        }
      }
    }
  }
  return content;
}

export = NodeVM

