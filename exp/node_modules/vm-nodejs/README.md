
This is a small JavaScript library which attempts to emulate the NodeJS runtime
on a V8 VM. It tries to to be as fully compatible with the NodeJS API as
possible, while allowing select features to be hooked into. For now, the hooks
are limited to the
[require()](https://nodejs.org/api/modules.html#modules_require)-procedure.

:mag: Found an inconsistency with the official NodeJS API that makes some
module not work with this VM? Please report it as soon as possible in the
[issue tracker](https://github.com/samvv/vm-nodejs/issues)!

## Why

**vm-nodejs** is different from [vm2](https://github.com/patriksimek/vm2) in
the sense that it does not attempt to provide full isolation, and because of
this it is much more lightweight. Above that, it allows hooking into the NodeJS
internals in a way that [vm2](https://github.com/patriksimek/vm2) does not
allow.

 - Run multiple programs in one process that share the same dependencies in
   environments with limited memory
 - Detect when a script was required and reload dependencies
   ([watch-require](https://npmjs.com/package/watch-require))

:warning: This library is not meant at all to provide complete isolation,
merely a way to run multiple NodeJS instances in one process. If you need
complete isolation, see the [vm2](https://npmjs.com/package/vm2) package.

## Installation

```
$ npm i --save vm-nodejs
```

## API

```js
const NodeVM = require('vm-nodejs')
```

### module.reload()

Reloads the module and all of its dependencies and returns a fresh `Module`
object as if `require()` had been called for the first time on the module
itself and its dependencies.

### module.children

The module objects required by this one.

### module.exports

The module.exports object is created by the Module system. Sometimes this is not acceptable; many want their module to be an instance of some class. To do this, assign the desired export object to module.exports. Note that assigning the desired object to exports will simply rebind the local exports variable, which is probably not what is desired.

### module.filename

The fully resolved filename to the module.

### module.id

The identifier for the module. Typically this is the fully resolved filename.

### module.parent

The module that first required this one.

### module.require(id)

Provides a way to load a module as if require() was called from the original module.

### new NodeVM([options])

Create a new NodeJS virtual machine. Currently takes no options.

### nodevm.getModule(modulePath)

Acts in much the same way as
[require()](https://nodejs.org/api/modules.html#modules_require)-procedure,
except that paths are resolved relative to the current working directory and it
returns a reference to the `Module` object instead of its exports.

### nodevm.on('require', cb)

Will trigger `cb` each time a new require statement is executed within the
context of the NodeJS VM. The callback is triggered with a single argument `e`
which contains the following properties:

 - **module**: a module instance that represents the module being required

```js
const NodeVM = require('vm-nodejs')

const node = new NodeVM()

node.on('require', e => {
  console.log(`Required ${e.module.filename}`)
})

node.getModule('index.js')
```

## License

The MIT License

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

